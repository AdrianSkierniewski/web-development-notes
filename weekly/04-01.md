Monday, 1 April 2013 
============================================================

Learning a little bit more about git.

Configuration information is stored in these files:

    ~/.gitconfig          (global for user)
    project/.git/config   (local to project)

git add just adds changes (including in new files)

    git add .             (adds all files in directory)
    git commit -a         (stages all tracked files with modifications)
    git commit -m '<msg>' (commit everything with a comment; don't open editor)

Use a .gitignore file in a directory to ignore files and folders. List each type of file to be ignored. If you need to track specific files among ignored files, use a ! to disregard the ignore, and track those files:

    temp/*.txt              (ignore every .txt file in temp)
    !temp/important.txt     (track important.txt)

Parts of git:

    working directory       uncompressed files
    staging area (index)    lets you choose what to commit; good encapsulated messages
    git repository          

git diff is used to see changes that have been made over time.

    git diff              difference between working directory and staging area
    git diff --staged     shows difference between committed and staged
    git diff HEAD         difference between working dir and HEAD (repository)
    git diff <hash> <file>  changes to <file> since <commit hash>
    
git log shows a history of commits over time

    git log               basic history of commits over time
    git log --stat        includes statistics  (files changed, insertions/deletions)
    git log --oneline     Shows each commit on one line  (hash, title)
    git log --graph       Shows graph of the current branch
    git log --all         Shows changes to all branches
    git log --decorate    Shows which branch the commit points to
    git log --oneline --graph --all --decorate   shows one-line graph of all branches
    git log --pretty='x'  Shows log with formatted output (which can be used elsewhere)
                          (see http://git-scm.com/docs/git-log for params) Examples:
                            %h   abbreviated hash
                            %t   abbreviated tree hash
                            %an  author name
                            %ad  author date
                            %ar  author date (relative)
                            %cn  committer name
                            %s   subject (commit message)
    git log --grep='x'    Limit output to those with log message matching regex

    alias gl='git log --oneline --graph --all --decorate'
    
    
Branches
---------

Master branch is there by default. Work on new, experimental features in new branches. You can switch branches at any time. When you commit, it will commit to the active branch.

    git branch              shows list of branches
    git branch <name>       create a new branch
    git branch -d <name>    delete the named branch
    git checkout <name>     swich to the named branch
    git checkout -b <name>  create and switch to a new branch
    git merge <name>        merge the named branch with the active branch
    git rebase <name>       rewind HEAD to branch point, apply branch changes, 
                            then replay additional changes to HEAD
                            (makes the log linear, so it looks like there was no branching)

    git push -u origin <name>   Push latest commit from branch <name> to origin repository (github)
                                (create the origin repository if it doesn't already exist)
    


Tuesday, 2 April 2013 
============================================================

I think I want my tests to go off of controller actions, rather than URIs. This way, if the routes ever changed later, the tests would still work.

Instead of: 

    $response = $this->get('items/1');

use:

    $response = $this->action('GET', 'ItemsController@show', '1');



    
Wednesday, 3 April 2013 
============================================================

Yesterday, I tried again to figure out a way to test my models with unit tests, and no touching a database. I asked about it on the #laravel group, and got a bunch of answers, but I think they were all about mocking the models while testing controllers. And one link to using an in-memory database (which is what I'm currently using). 

Maybe I'm the first person to have this concept?

Basically, I want a db layer (like MySqlConnection, MySqlBuilder, MySqlGrammar, etc.) that I can use for tests, that never touches the disk. It should touch the disk, once, to read in the migrations and seeds, store the results of those in a static place that doesn't get modified by any tests, and then simply reload the data (from memory) when the next test happens. That way, all of the tests are fast.

Another way would be to just mock the db layer, and return the results that I'd expect from an actual database. Again, everything happening in memory, and very fast.

Here's what I've been trying (but none of these techniques have worked):

    // TODO: Figure out how to use an array instead of a database
    public function testSearchByRecordNumberAsArray()
    {
        $this->app->db->pretend(function(){
            return array('foo'=>'bar');
        });

        $item = new Item;
        $a = $item->something('a');
    }
   
    public function testSearchByRecordNumberAsArray()
    {
        $mock = \Mockery::mock('Illuminate\Database\ConnectionInterface');
        $mock->shouldReceive('select')->Yesonce()->andReturn('foo');
        $app['db'] = $mock;
        $item = new Item;
        $a = $item->something('q');
    }
        
    public function testSearchByRecordNumberAsArray()
    {
        $mock = \Mockery::mock('Illuminate\Database\ConnectionInterface');
        $mock->shouldReceive('select')->with(\Mockery::any(), array('*'))
            ->once()->andReturn('foo');
        App::instance('Illuminate\Database\ConnectionInterface', $mock);  
        DB::shouldReceive('select')->once()->andReturn('bar')      ;
        $this->assertEquals('bar', $item->search(1)->name, 'should find bar');
    }
        
    public function testSearchByRecordNumberAsArray()
    {
        DB::shouldReceive('selectOne')->andReturn('bar');
        DB::shouldReceive('select')->once()->andReturn('foo');

        $this->assertEquals('foo', $item->search(1)->name, 'should find foo');
    }
    
    public function testSearchByRecordNumberAsArray()
    {
        $mock = new EloquentModelFindStub;
        App::instance('Illuminate\Database\ConnectionInterface', $mock);
        $result = Item::find(1);
        $this->assertEquals('foo', $result);
    }

    public function testSearchByRecordNumberAsArray()
    {
        $mock = new EloquentModelFindStub;
        App::instance('Illuminate\Database\Eloquent\Builder', $mock);
        $result = Item::find(1);
        $this->assertEquals('foo', $result);
    }
    
    class EloquentModelFindStub extends Illuminate\Database\Eloquent\Model {
        public function newQuery()
        {
            $mock = \Mockery::mock('Illuminate\Database\Eloquent\Builder');
            $mock->shouldReceive('find')->once()->with(1, array('*'))->andReturn('foo');
            return $mock;
        }
    }

        
Lots of different ways to try, basically, the same thing... Mocking out the database access layer, so I can run tests significantly faster.

For now, let's just forget about this. The in-memory database is slower, but not terrible.
